#lang eopl
#|
Autores:
 CASTAÑO HOLGUIN, JUAN ESTEBAN,1968098-3743.
 MONTANO HURTADO, HAROLD ANDRES,1968067-3743.
 MURILLAS MONDRAGON, GERMAN DAVID,2067549-3743.
 VICTORIA RODRIGUEZ, NICOLAS FELIPE,1767315-3743.
|#

;Constructores
(define th-vacio
  (lambda ()
    (list 'th-vacio)))

(define th-novacio
  (lambda (item reg)
    (list 'th-novacio item reg)))

(define itemElm
  (lambda (key dato)
    (list 'itemElm key dato)))

(define lnumvacia
  (lambda ()
    (list 'lnumvacia)))

(define lnumnovacia
  (lambda (num lst)
    (list 'lnumnovacia num lst)))

;Predicados
(define th-vacio?
  (lambda (exp)
    (equal? 'th-vacio (car exp))))

(define th-novacio?
  (lambda (exp)
    (equal? 'th-novacio (car exp))))

(define itemElm?
  (lambda (exp)
    (equal? 'itemElm (car exp))))

(define lnumvacia?
  (lambda (exp)
    (equal? 'lnumvacia (car exp))))

(define lnumnovacia?
  (lambda (exp)
    (equal? 'lnumnovacia (car exp))))

;Extractores
(define th-novacio->item
  (lambda (th-novacio)
    (cadr th-novacio)))

(define th-novacio->reg
  (lambda (th-novacio)
    (caddr th-novacio)))

(define itemElm->key
  (lambda (itemElm)
    (cadr itemElm)))

(define itemElm->dato
  (lambda (itemElm)
    (caddr itemElm)))

(define lnumnovacia->num
  (lambda (lnumnovacia)
    (cadr lnumnovacia)))

(define lnumnovacia->lst
  (lambda (lnumnovacia)
    (caddr lnumnovacia)))

;Area de programacion
#|
<dato> ::= <numero> | <simbolo> | <lnumero> | <lsimbolo>
<lnumero> ::= '()
          ::= <numero> <lnumero>

buscar-llave: llave , registro --> dato
Proposito:
Dentro del registro enviado se buscará (de forma recursiva) la llave,
para retornar el dato, almacenado en la llave
|#
(define buscar-llave
  (lambda (simbolo th)
    (cond
      [(th-vacio? th) '()]
      [(th-novacio? th)
       (let
           ([item (th-novacio->item th)])
         (if
          (itemElm? item)
          (if (equal? (itemElm->key item) simbolo)
              (itemElm->dato item)
              (buscar-llave simbolo (th-novacio->reg th))
              )
          (eopl:error "un elemento no es de tipo itemElm")
          )
         )]
      [else eopl:error "ingreso de datos no valido"]
      )
    )
  )

#|
<dato> ::= <numero> | <simbolo> | <lnumero> | <lsimbolo>
<lnumero> ::= '()
          ::= <numero> <lnumero>
<tabla-hash> := th-vacio '()
             := th-novacio <item><tabla-hash>

sumar-valores: lista --> lista
Proposito:
Se ingresa una lista de tablas hash, y los valores de se sumaran (de forma recursiva),
y se retornará listas que su primer valor será la llave, y el segundo la suma de cada
valor de la lista.
|#
(define sumar-valores
  (lambda (th)
    (cond
      [(th-vacio? th) '()]
      [(th-novacio? th)
       (letrec
            ([item (th-novacio->item th)]
             [sumar-lista (lambda (lnum)
                       (cond
                         [(lnumvacia? lnum) 0]
                         [else (+ (lnumnovacia->num lnum)
                                  (sumar-lista (lnumnovacia->lst lnum)))]
                         )
                       )]
             )         
         (cons (list (itemElm->key item) (sumar-lista (itemElm->dato item)))
               (sumar-valores (th-novacio->reg th)))
           )
       ]
      [else eopl:error "ingreso de datos no valido"]
    )
  )
)

;f = {a : ’ ( 1 2 3 ) , b : ’ ( 1 ) , c : ’ ( 1 , 2 ) }
(define f
  (th-novacio (itemElm 'a (lnumnovacia 1 (lnumnovacia 2 (lnumnovacia 3 (lnumvacia)))))
              (th-novacio (itemElm 'b (lnumnovacia 1 (lnumvacia)))
                          (th-novacio (itemElm 'c (lnumnovacia 1 (lnumnovacia 2 (lnumvacia)))) (th-vacio)))))

(buscar-llave 'a f)
(sumar-valores f)